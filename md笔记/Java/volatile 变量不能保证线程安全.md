# volatile 变量不能保证线程安全

在《Java并发编程实战》这一书中，volatile 是这么定义的：

> Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。

这样的定义说明两点：volatile 变量是一种稍弱的同步机制；volatile 能确保变量在不同线程中的可见性。

因此，voaltile 可以看做是 synchronized 的一种轻量级实现（synchronized 也被称为重量级锁），因为它不会引起线程上下文的切换和调度。但不能完全代替它，因为 volatile 变量的同步性较差，虽然更简单且开销低，拥有 synchronized 可见性的特性，但并没有其原子性的特性，使用起来更容易出错。

那么，在以下的一些场景，我们会常常使用到 volatile：

* 状态的改变
* 读多写少的情况



## 线程的本地内存

假设存在两个不同的线程并发执行，而且线程 1 先执行一部分代码，然后线程 2 开始执行。

如果不用 volatile，那么线程 1 对于某一个变量的修改对线程 2 来说未必是可见的，对于线程 2 而言，它读取到的该变量的值，有可能是线程 1 对其进行修改前的值。

如果使用 volatile，那么就会存在以下过程：

* 每次修改 volatile 变量都会同步到主内存中
* 每次读取 volatile 变量的值都会强制从主存中读取最新的值（强制 JVM 不可优化 volatile 变量 - JVM 优化后变量读取会使用 cpu 缓存而不从主存中读取）
* 线程 1 在写入 volatile 变量之前可见的变量，在线程 2 读取该 volatilve 变量以后，线程 2 对它们也是可见的。也就是说，写 volatile 变量类似于退出同步块，读 volatile 类似于进入同步块。



## volatile 变量的可见性

volatile 变量之所以能用来确保将变量的更新操作通知到其他线程，是因为它不会被缓存在寄存器或者其他处理器不可见的地方，在读取该变量时总是会返回最新写入的值。

这个过程涉及到线程对变量的操作以及主存与工作内存之间的具体交互。Java 使用的是共享变量模型，一个线程读取一个被其他线程修改后的变量值，必须要等待对方将修改后的值写入到主内存后，再进行读取。其结构大致如下：

![](D:\3.Workplace\Algorithms\md笔记\Java\Java内存模型.JPG)

Java 的内存模型定义了以下八种操作：

* lock（锁定）：将对象变为线程独占的状态。
* unlock（解锁）：将线程独占状态的对象的锁释放出来。
* read（读取）：从主内存读取数据。
* load（载入）：将从主内存读取的数据写入到工作内存中。
* use（试用）：线程在工作内存中使用对象。
* assign（赋值）：对工作内存中的对象进行赋值。
* store（存储）：将工作内存中的对象传送到主内存中。
* write（写入）：将对象写入主内存中，并覆盖旧值。

volatile 的作用有：保证其所修饰的变量具有可见性；可以防止指令重排序，主要是因为 volatile 对这八种操作有两个特殊的限定。

1. use 动作之前必须要有 read 和 load 动作，这三个动作必须是连续出现的。具体表现为，每次要在工作内存中使用 volatile 变量之前，都必须到主存中读取最新的值，再将其载入到工作内存中，方可进行使用。
2. assign 动作之后必须是 store 和 write 动作，同样的这三个动作必须连续出现。具体表现为，每次在工作内存中修改 volatile 变量的值后，必须把值存储并写入主内存中。也就是说，被 volatile 修饰的对象，其 assign，store，write 这三个操作时原子的（atomic），中间不会间断，会马上将数据同步到主内存中，并通过缓存一致性（如 MESI 协议）通知其他缓存中的副本过期。

以上两条限定的存在就保证了线程每次获取 volatile 变量时，变量的值肯定是最新的。而操作没有用 volatile 修饰的变量，可能会在 assign，store，write 这三个操作之间插入其他操作，导致修改后的数据不能及时同步到主内存中，则其他线程读取的可能是过期的旧数据，因此不能保证每次都能获取到最新的变量值。这里也能体现出 volatile 在多线程环境中稍弱的同步功能，制约了各个线程对 volatile 修饰的变量的共享。



## 缓存一致性

MESI 协议







## 防止指令重排序

指令重排序是指 JVM 为了优化指令，提高程序运行效率，在不影响**单线程程序**执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。多线程的情况下指令重排序就会给程序带来问题。

重排序会遵守两个规则：

- **as-if-serial 规则**：=指不管如何重排序（单线程）程序的结果不能被改变。

- **happens-before 规则**：前一个操作的结果可以被后续的操作获取

- - **程序顺序规则：**一个线程中的每个操作，happens-before 于线程中的任意后续操作。
    - **监视器锁规则**：一个锁的解锁，happens-before 于随后对这个锁的加锁。
    - **volatile 变量规则：**对一个 volatile 域的**写**，happens-before 于任意后续对这个 volatile 域的**读**。
    - **传递性：**如果（A）happens-before（B），且（B）happens-before（C），那么（A）happens-before（C）。
    - **线程 start() 规则：**主线程 A 启动线程 B，线程 B 中可以看到主线程启动 B 之前的操作。也就是 start() happens-before 线程 B 中的操作。
    - **线程 join() 规则：**主线程 A 等待子线程 B 完成，当子线程 B 执行完毕后，主线程 A 可以看到线程 B 的所有操作。也就是说，子线程 B 中的任意操作，happens-before join() 的返回。
    - **中断规则：**一个线程调用另一个线程的 interrupt，happens-before 于被中断的线程发现中断。
    - **终结规则：**一个对象的构造函数的结束，happens-before 于这个对象 finalizer 的开始。



JVM 和 CPU 都会为了优化性能，在程序运行时采用指令重排序。如果变量使用了 volatile 进行修饰，那么与该变量相关的部分会被禁止指令重排序，其操作必须是在指定位置根据指定顺序执行的。

具体来说，volatile 关键字通过 **“内存屏障”** 的方式来防止指令被重排序。内存屏障又称内存栅栏，是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。

为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。大多数的处理器都支持内存屏障的指令。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java 内存模型采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略：

- 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
    - 在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。
- 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
    - 在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。
- 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
    - 在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。
- 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。
    - 在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。

volatile 使用内存屏障禁止指令重排序实际上表现为以下的规则：

* 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行。
* 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

也就是说，执行到 volatile 变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对 volatile 变量及其后面语句可见。



## 线程安全性

在多线程环境下，一个线程修改了 volatile 修饰的变量后，其他线程能立刻读取到该变量的最新值。但是，volatile 并不能保证所有线程是串行去访问同一个变量的。在多个线程同时对同一个共享变量进行修改的时候，依然会出现线程安全问题。

举个例子，在多线程操作中，i++并不是线程安全的。++操作并不是原子的，它需要经过读取、计算、写入三个操作，具体实现的字节码如下：

```java
void f1();
Code:
0: aload_0
1: dup
2: getfield #2; //Field i:I
5: iconst_1
6: iadd
7: putfield #2; //Field i:I
10: return
```

这个过程可以理解存在下面的操作：

```java
temp = i;
temp = temp + 1;
i = temp;
```

如果初始的 i = 1，我们有两个线程分别先后执行 i++ 这一操作，那么最后得到的结果应该是 i = 3。但是，考虑这样一种情况：

* 线程一从主存中读取的 i = 1 并加载到线程一的工作内存中，然后执行 temp = temp + 1，那么此时在线程一的工作内存中，i 应该等于 2。
* 如果此时线程一挂起，线程 2 执行 i++ 操作，那么在主内存中 i 的值就会被更新为 2。
* 随后，线程一由于缓存一致性，接受到副本过期通知，于是会判断此时工作内存中的 i 失效，并强制从主内存中重新读取 i 的值，此时 i = 2。
* 线程一执行最后剩下的操作 i = temp，接着将结果写入主内存。这样最终在主内存中的结果就为 i = 2。

从上述的过程中可以看出，volatile 修饰的变量在修改后都会及时写入主存，对其它线程的可见性可以理解为其它线程能够获知自己当前的副本是过期的，并在当前状态下马上从主存中重新读取该值。

要想 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：

* 对变量的写操作不依赖于当前变量的读（只用写入这一原子操作）
* 该变量没有包含在其他变量的不变式中（写入前不需要读取）



## 与 synchronized 的区别

要解决这样的线程同步问题，需要使用 synchronized 或者 Atomic 系列的包装类，但是这样同时也会增加性能开销。

volatile 与 synchronized 的主要区别包括：

* volatile 只能修饰实例变量和类变量，而 synchronized 可以修饰方法，以及代码块。
* volatile 保证数据的可见性，但是不保证原子性；而synchronized 是一种排他（互斥）的机制，既保证可见性，又保证原子性。
* volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
* volatile 可以看做是轻量版的 synchronized，volatile 不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用 volatile 来代替 synchronized，因为**赋值本身是有原子性**的，而 volatile 又保证了可见性，所以就可以保证线程安全了。