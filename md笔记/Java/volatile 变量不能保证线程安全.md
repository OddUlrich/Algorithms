# volatile 变量不能保证线程安全

在《Java并发编程实战》这一书中，volatile 是这么定义的：

> Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。

这样的定义说明两点：volatile 变量是一种稍弱的同步机制；volatile 能确保可见性。



## volatile 变量的可见性

volatile 变量之所以能用来确保将变量的更新操作通知到其他线程，是因为它不会被缓存在寄存器或者其他处理器不可见的地方，在读取该变量时总是会返回最新写入的值。

这个过程涉及到线程对变量的操作以及主存与工作内存之间的具体交互。Java 使用的是共享变量模型，一个线程读取一个被其他线程修改后的变量值，必须要等待对方将修改后的值写入到主内存后，再进行读取。其结构大致如下：

![](D:\3.Workplace\Algorithms\md笔记\Java\Java内存模型.JPG)

Java 的内存模型定义了以下八种操作：

* lock（锁定）：将对象变为线程独占的状态。
* unlock（解锁）：将线程独占状态的对象的锁释放出来。
* read（读取）：从主内存读取数据。
* load（载入）：将从主内存读取的数据写入到工作内存中。
* use（试用）：线程在工作内存中使用对象。
* assign（赋值）：对工作内存中的对象进行赋值。
* store（存储）：将工作内存中的对象传送到主内存中。
* write（写入）：将对象写入主内存中，并覆盖旧值。

volatile 的作用有：保证其所修饰的变量具有可见性；可以防止指令重排序，主要是因为 volatile 对这八种操作有两个特殊的限定。

1. use 动作之前必须要有 read 和 load 动作，这三个动作必须是连续出现的。具体表现为，每次要在工作内存中使用 volatile 变量之前，都必须到主存中读取最新的值，再将其载入到工作内存中，方可进行使用。
2. assign 动作之后必须是 store 和 write 动作，同样的这三个动作必须连续出现。具体表现为，每次在工作内存中修改 volatile 变量的值后，必须把值存储并写入主内存中。也就是说，被 volatile 修饰的对象，其 assign，store，write 这三个操作时原子的（atomic），中间不会间断，会马上将数据同步到主内存中，并通过缓存一致性（如 MESI 协议）通知其他缓存中的副本过期。

以上两条限定的存在就保证了线程每次获取 volatile 变量时，变量的值肯定是最新的。而操作没有用 volatile 修饰的变量，可能会在 assign，store，write 这三个操作之间插入其他操作，导致修改后的数据不能及时同步到主内存中，则其他线程读取的可能是过期的旧数据，因此不能保证每次都能获取到最新的变量值。这里也能体现出 volatile 在多线程环境中稍弱的同步功能，制约了各个线程对 volatile 修饰的变量的共享。



## 缓存一致性

MESI 协议







## 防止指令重排序

JVM 和 CPU 都会为了优化性能，在程序运行时采用指令重排序。如果变量使用了 volatile 进行修饰，那么与该变量相关的部分会被禁止指令重排序，其操作必须是在指定位置根据指定顺序执行的。





## 线程安全性

在多线程环境下，一个线程修改了 volatile 修饰的变量后，其他线程能立刻读取到该变量的最新值。但是，volatile 并不能保证所有线程是串行去访问同一个变量的。在多个线程同时对同一个共享变量进行修改的时候，依然会出现线程安全问题。

举个例子，在多线程操作中，i++并不是线程安全的。++操作并不是原子的，它需要经过读取、计算、写入三个操作，我们假设这个过程存在下面的操作：

```java
temp = i;
temp = temp + 1;
i = temp;
```

如果初始的 i = 1，我们有两个线程分别先后执行 i++ 这一操作，那么最后得到的结果应该是 i = 3。但是，考虑这样一种情况：

* 线程一从主存中读取的 i = 1 并加载到线程一的工作内存中，然后执行 temp = temp + 1，那么此时在线程一的工作内存中，i 应该等于 2。
* 如果此时线程一挂起，线程 2 执行 i++ 操作，那么在主内存中 i 的值就会被更新为 2。
* 随后，线程一由于缓存一致性，接受到副本过期通知，于是会判断此时工作内存中的 i 失效，并强制从主内存中重新读取 i 的值，此时 i = 2。
* 线程一执行最后剩下的操作 i = temp，接着将结果写入主内存。这样最终在主内存中的结果就为 i = 2。

从上述的过程中可以看出，volatile 修饰的变量在修改后都会及时写入主存，对其它线程的可见性可以理解为其它线程能够获知自己当前的副本是过期的，并在当前状态下马上从主存中重新读取该值。