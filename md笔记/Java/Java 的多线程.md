# Java 的多线程



Java 多线程实现方式主要有三种：

1、继承Thread类

2、 实现Runnable接口

3、使用ExecutorService、Callable、Future实现有返回结果的多线程。

其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。实现Callable接口，线程结束后可以有返回值，但是该方式是依赖于线程池的。由于Java只有单继承，所以，第一种方法只能继承一个Thread；第二种则可以实现多继承。



Java 的线程状态主要包括以下 4 种：

- 1、初始状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread（）。
- 2、就绪状态、可运行状态（Runnable）：当调用线程对象的 start() 方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待 CPU 调度执行，获取 cpu 的使用权，而不是立即就会执行。
- 3、运行状态（Running）：可运行状态的线程获得了 cpu 时间片，执行程序代码。 当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。（**就绪状态是进入到运行状态的唯一入口**，线程要想进入运行状态执行，首先必须处于就绪状态中）。
- 4、阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权， 停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。 根据阻塞产生的原因不同，阻塞状态又可以分为三种：
    - 等待阻塞：运行状态中的线程执行 wait（）方法，使线程进入到等待阻塞状态，JVM 会把该线程放入等待队列中。
    - 同步阻塞：正在运行态的线程在获取对象的同步锁时，若该同步锁被别的线程占用，获取 synchronized 同步锁失败 , 它会进入同步阻塞状态 ,则 JVM 会把该线程放入**锁池**中，等待释放资源。
    - 其他阻塞：运行中的线程执行 Thread.sleep（）或 t.join（）方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep（）状态超时、join（）等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行状态。
- 5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

![](https://uploadfiles.nowcoder.com/images/20180709/3807435_1531103859654_3658A873352D1D5FB9EF74D9F9F1F0B5)

只有 runnable 到 running 时才会占用 cpu 时间片，其他都会出让 cpu 时间片。
线程的资源有不少，但应该包含 CPU 资源和锁资源这两类。







如果在静态方法上使用同步，则会先获取该类的”class“对象锁，此时其他线程不能进入这个类的任何静态同步方法。这与实例方法的同步不同，多个线程可以同时访问不同实例的同步实例方法。





## Runnable 接口





## Thread 类







Thread.start（）方法 （native） 启动线程，使之进入就绪状态，当 cpu 分配时间给该线程时，由 JVM 调度执行 run（）方法

我们需要 run（）和 start（）这两个方法是因为 JVM 创建一个单独的线程不同于普通方法的调用，所以这项工作由线程的 start 方法来完成，start 由本地方法实现，需要显示地被调用，使用这俩个方法的另外一个好处是任何一个对象都可以作为线程运行，只要实现了 Runnable 接口，这就避免因继承了 Thread 类而造成的 Java 的多继承问题。





## wait()、sleep()、yield()

这三个方法都够在 Java 中用来暂停线程，三者的特点各不一样。



| 内容     | wait（）                                     | sleep（）                                  | yield（）                      |
| -------- | -------------------------------------------- | ------------------------------------------ | ------------------------------ |
| 定义位置 | Object 类的实例方法                          | Thread 类的静态方法                        | Thread 类的静态方法            |
| 作用范围 | 在 synchronized 代码块中调用，作用于当前对象 | 作用于当前线程                             | 作用于当前线程                 |
| 释放资源 | 释放持有的对象管程和同步资源锁               | 让出 CPU，不释放持有的对象管程和同步资源锁 | 仅释放线程所占有的 CPU 资源    |
|          | 能被 notify 和 notifyAll 唤醒                | 能被其他线程通过 interrupt（）方法唤醒     |                                |
|          |                                              |                                            | 线程在唤醒之后会立即进入就绪态 |



### wait 方法

wait（）是 Object 的实例方法，用于线程间通信，需要在 synchronized 同步代码块中调用，作用于当前对象，使当前线程处于**不可运行状态**。释放同步资源锁，以便其他正在等待该资源的线程得到锁而运行。

当一个线程调用 wait（）方法时，被暂停的线程会首先获取当前对象的对象锁，当前对象必须在锁对象内保持同步，然后把当前线程添加到等待队列中。随后另一线程可以同步同一个对象锁来调用 Object.notify（），唤醒原来等待中的线程，然后释放该锁。进入 wait 状态的线程能够被 notify 和 notifyAll 线程唤醒。只用当其他线程调用了 nofity（）方法，之前调用 wait（）方法的线程才会解除 wait 状态，参与竞争同步资源锁。但被唤醒后的线程只是能进入锁池竞争资源，并不会马上获得同步资源所。

wait 通常有条件地执行，线程会一直处于 wait 状态，直到某个条件变为真。



join（）方法是一种特殊的 wait（）方法。当前线程调用另一个线程的 join 方法以后，当前线程就会进入阻塞状态，直到另一个线程执行结束，再继续执行。这个方法也是需要捕捉异常。



### sleep 方法

sleep（）是 Thread 的静态方法，作用在当前线程上，用于短时间暂停当前线程，使之处于**非运行状态**，时间到了自动恢复。它不要求一定要在 synchronized 同步代码块中调用。

当一个线程调用 sleep（）方法时，不会释放它所持有的管程，仅仅让线程进入睡眠状态，被暂停的线程在唤醒之后会先立即进入**就绪态**（Runable state）。如果在这期间，其他的线程中断了当前休眠的线程，sleep 方法会抛出一个 Interrupted Execution。

Java 中的 sleep 方法有两种，一个指定毫秒参数，另一个指定毫秒和纳秒两个参数：

```java
sleep(long millis);
sleep(long millis, int nanos);
```



suspend（）是一种过时的方法，功能类似于 sleep（），但 suspend（）会导致线程进入停止状态，该线程会一直持有所持有的对象的锁，容易引起死锁问题。



### yield 方法

yield（）方法被调用时，会临时暂停当前正在执行的线程，仅释放线程所占有的 CPU 资源，来让有同样优先级的、正在等待的线程有机会执行。如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。执行了 yield 的线程什么时候会继续运行，谁能获得 CPU，完全由线程调度器来决定，不同的厂商可能有不同的行为。yield 方法不保证当前线程会暂停或者停止，但是可以保证当前呈现在调用 yield 方法时会放弃 CPU，所以依赖 yield（）方法是不可靠的。



如果需要让线程暂停特定一段时间，可以使用 sleep（）方法；如果想要实现线程间通信就使用 wait（）方法。





1）wait()是Object的实例方法，在synchronized同步环境使用，作用当前对象，会释放对象锁，需要被唤醒。

2）sleep()是Thread的静态方法，不用在同步环境使用，作用当前线程，不释放锁。

3）yield()是Thread的静态方法，作用当前线程，释放当前线程持有的CPU资源，将CPU让给优先级不低于自己的线程用，调用后进入就绪状态。