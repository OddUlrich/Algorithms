# JVM 的内存模型





## JVM 运行时数据区

Java 虚拟机在 Java 程序运行时会将其管理的内存区域划分为若干个不同的数据区域，这些区域有各自的功能，以及它们创建、回收的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。

Java 虚拟机所管理的内存如下图所示：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

### 程序计数器

程序计数器属于**线程私有**，内存空间小。**字节码解释器**的工作就是通过改变这个计数器的值来**选取下一条需要执行指令的字节码指令**，像是分支、循环、跳转、异常处理、线程回复等基础功能都需要依赖程序计数器来完成。

如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，那么这个计数器的值则为 Undefined。这个内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。



### Java 虚拟机栈

虚拟机栈同样属于**线程私有**，生命周期与线程一致。它描述了 Java 方法执行的内存模型，每个方法在执行时都会创建一个**栈帧（Stack frame）**用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**每一个方法**从调用直到结束，都对应着一个栈帧从虚拟机栈中入栈到出栈的过程。当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。

* 栈帧内容：局部变量表、操作数栈、动态链接、返回地址等。
    * 局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。
    * 操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入到方法区 code 属性的 max_stacks 中）。内存元素可以是任意 Java 基本类型，32 位数据占用栈空间为 1, 64 位占用空间为 2。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令在栈中存取数据。
    * 动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。
    * 返回值：如果方法有返回值的话，压入调用者栈帧中的操作数栈中，并且指向方法调用指令后面的一条指令地址。
* StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。
* OutOfMemoryError：可动态拓展的虚拟机在拓展时无法申请到足够的内存。



### 本地方法栈

同样属于**线程私有**。本地方法栈与 Java 虚拟机栈的区别是，Java 虚拟机栈是为虚拟机执行 Java 方法（字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。本地方法栈也会存在 StackOverflowError 和 OutOfMemoryError 异常。



### Java 堆

对于绝大多数应用来说，这块区域就是 JVM 所管理内存中最大的一块，属于线程共享，主要用于存放对象实例和数组。在 Java 堆内部会划分出多个线程私有的分配缓冲区，可以在物理上位于不连续的空间，但是逻辑上要连续。Java 堆是垃圾收集器管理的内存区域，因此很多时候都称为 “GC 堆”。

当堆中没有足够内存能完成实例分配，并且堆也无法拓展时，就会抛出 OutOfMemoryError 异常。



### 方法区

方法区属于**线程共享**的内存区域，用于存储已经被虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。

方法区中存在一个**运行时常量池**，用于存放编译器生成的各种字面量和符号引用。编译器和运行期都可以将常量放入池中，但是该空间内存有限，无法申请新的空间时会抛出 OutOfMemoryError 异常。



## Java 内存模型 JMM （Java Memory Model）

Java 的并发采用的是“**共享内存**”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据进行交互的，它们之间的交互只能通过共享变量实现。

Java 内存模型规定所有变量都存储在主内存中，每个线程还有自己的工作内存。这样设计的主要目的是为了定义程序中各个变量的访问规则。线程的工作内存中保存了被该线程使用到的从主内存拷贝过来的变量副本，线程对变量的所有操作都必须在工作内存中执行，而不能直接访问主内存中的变量。主内存主要对应 Java 堆中的实例数据部分，而工作内存只要对应于虚拟机栈中的部分区域。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

Java 线程之间的通信由内存模型 JMM 控制。其决定了一个线程对变量的写入何时对另一个线程可见，通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。

Java 的内存模型规定了工作内存与主内存之间交互的协议，定义了以下八种操作：

- lock（锁定）：作用于主内存的变量，将对象变为线程独占的状态。
- unlock（解锁）：作用于主内存的变量，将线程独占状态的对象的锁释放出来。
- read（读取）：作用于主内存的变量，从主内存读取数据到工作内存中。
- load（载入）：作用于工作内存的变量，将从主内存读取的数据写入到工作内存中。
- use（试用）：作用于工作内存的变量，线程在工作内存中使用对象，传递给一个执行引擎。
- assign（赋值）：作用于工作内存的变量，把执行引擎接受到值赋值给工作内存中的变量。
- store（存储）：将工作内存中的对象传送到主内存中。
- write（写入）：将对象写入主内存中，并覆盖旧值。

通过上面 Java 内存模型的概述，我们会注意到这么一个问题，每个线程在获取锁之后会在自己的工作内存来操作共享变量，操作完成之后将工作内存中的副本回写到主内存，并且在其它线程从主内存将变量同步回自己的工作内存之前，共享变量的改变对其是不可见的。

即其他线程的本地内存中的变量已经是过时的，并不是更新后的值。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用 synchronized 或者 Lock 这些方式太重量级了，比较合理的方式其实就是 volatile。volatile 保证可见性的原理是在每次访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本。所以 volatile 关键字的作用之一就是保证变量修改的实时可见性。



## 堆的内存分配与回收策略

一般来说 Java 堆的内存模型如下图所示：


![img](https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhrpQ7L1ibjvdBWib7LvJiadpBcy7kFicCo7Ik3e4swEib23wwVV67y1EC2cMPNDbDDqnhpUb8fCXKjR3Rw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

Java 堆的内存划分为新生代（Young Memory）、老年代（Old Memory）、永久代（Perm）。其中在 JDK 1.8 中，永久代被移除，使用 MetaSpace 代替。图中涉及到一些常用的参数：

* -Xms：初始堆大小
* -Xmx：最大堆大小
* -XX:NewSize=n：设置新生代大小
* -XX:NewRatio=n：设置新生代和老年代的比值。比如 n 取 3，表示新生代与老年代比值为 1:3。
* -XX:SurvivorRatio=n：新生代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。
* -XX:MaxPermSize=n：设置永久代大小
* -XX:+UserSerialGC：设置串行收集器



之所以将堆进行分代，主要理由是为了**优化垃圾回收（GC）的性能**。

| 内存划分        | 含义                                                         | 内存回收                                                     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 新生代（Young） | 分为 Eden、Survivor （From）、Survivor （To）三个部分，比例默认为 8:1:1；<br />对象优先分配在新生代的 Eden 区，少数情况会直接分配到老年代中；<br /> | 采用复制清除算法（Copying）<br />每次只使用 Eden 和其中一块 Survivor 区，经过 GC 后，将存活对象复制到未使用的 Survivor 区（存活比例大于 10 % 时，多出来的对象直接进入老年代），清空 Eden 和之前使用的 Survivor 区；<br />内存不足时发生 Minor GC。 |
| 老年代（Old）   | 大对象直接进入老年代；<br />长期存活的对象将进入老年代；<br />动态对象年龄判定；<br />空间分配担保 | 采用标记-整理算法（Mark-Compact），每次 GC 只会回收一小部分的对象。 |
| 永久代（Perm）  | 在 JDK 1.8 中，Perm 被替换成 MetaSpace，原因是永久代进场内存不够用，或者发生内存泄漏。<br />MetaSpace（元空间）：主要存放在本地内存中。 |                                                              |

对象优先在 Eden 分配：对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。

