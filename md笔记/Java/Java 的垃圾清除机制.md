# Java 的垃圾回收机制

Java 的垃圾回收与内存分配策略是基于其内存模型设计而设计的。在 Java 的内存模型中，程序计数器、虚拟机栈、本地方法栈这三个区域都是属于线程私有，生命周期与线程一致，其中栈中的方法在其内部有序进行着入栈和出栈的操作。相比而言，Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能也不一样，一个方法中的多个分支需要的内存可能也不一样，只有在程序运行期才会知道哪些对象会被创建，因此这部分内存的分配和回收是动态的。Java 的垃圾回收主要就是关注这部分的内存。



## 判断对象存活

在进行内存回收之前，系统需要先判断哪些对象是可回收的，哪些是不可回收的。主要判断方法有下面几种。



### 1. 引用计数法

给对象添加一个引用计数器，根据当前的引用数来判断当前对象是否存在引用。但是不能解决循环引用的问题，也就是当两个实例对象内部彼此之间存在引用，但当我们将对这个两个的引用都置为 null 时。我们不在引用它们，但它们内部仍然存在的相互引用而无法被回收。



### 2. 可达性分析法

可达性分析法通过一系列的 “**GC Roots**” 对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象没有被 GC Roots 通过任何引用链相连时，说明该对象不可达，可以被回收。

这里可以作为 GC Roots 的对象有：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象

* 方法区中类静态属性所引用的对象
* 方法区中常量引用的对象
* 本地方法栈中 JNI（Native 方法）引用的对象。



自 JDK 1.2 后，Java 中引用的概念进行了扩充，从强到弱依次是：

* 强引用：类似于使用 new 关键字调用构建方法来创建的，只要强引用在就不回收。
* 软引用：SoftReference 类实现软引用。在系统将要发生内存溢出异常前，会把这个软引用对象列进回收范围之中进行二次回收。
* 弱引用：WeakReference 类实现弱引用。对象只能生存到下一个垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会将弱引用对象进行回收。
* 虚引用：PhantomReference 类实现虚引用。无法通过虚引获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



在可达性分析中被识别为不可达的对象，此时它们只是暂时处于“缓刑”阶段，并不会马上被回收。一个对象的真正死亡至少要经历两次标记过程：

* 对象在可达性分析中发现没有与 GC Roots 的引用链相连，那么它将会被进行第一次标记，并且进行一次筛选，筛选条件为此对象是否有必要执行 finalize（） 方法。当对象没有覆盖 finalize（）方法，或者 finalize（）方法已经被虚拟机调用过，那么虚拟机将这两种情况都是为“没有必要执行”。

    （也就是说，如果对象有覆盖 finalize（）方法，或者 finalize（）方法还没有被虚拟机调用过，那么该对象则有必要执行 finalize（）方法。）

* 如果对象被判定为有必要执行 finalize（）方法，那么它会被放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，并不保证或者等待它运行结束。finalize（）方法是对象逃脱死亡的最后一次机会，稍后 GC 将会对 F-Queue 中的对象进行第二次小规模的标记。如果对象在 finalize（）方法中能够重新与引用链上的任何一个对象建立关联，那么就能拯救自己。

之所以 Finalizer 线程只是触发，而不保证或者等待 finalize（）方法结束，是因为如果一个对象在 finalize（）方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。

这里需要注意的是，finalize（）方法只会被系统自动调用一次。面临下一次回收时，对象的 finalize（）方法不会被再次执行。而且 finalize（）方法具有以下特点需要注意：

- 永远不要主动调用某个对象的 finalize（）方法，该方法应该交给垃圾回收机制调用
- finalize（）方法是否合适被调用，是否被调用具有不确定性，不要把它当做一定会执行的方法
- 当 JVM 执行可恢复对象的 finalize（）方法时，可能会使得对象或系统中其他对象重新变成可达状态
- 当 JVM 调用 finalize（）方法出现异常时，垃圾回收机制不会报告异常，程序继续执行。



## 垃圾回收算法

主要的几种垃圾回收类型有：

- Minor GC：从新生代（包括Eden、Survivor区）回收内存。
    - 当 JVM 无法为一个新的对象分配内存的时候，越容易触发 Minor GC。所以分配率越高，内存越来越少，越频繁执行 Minor GC。
    - 执行 Minor GC 操作的时候，不会影响到永久代。从永久代到年轻代的引用，被当成 GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。
- Major GC：清理整个老年代，当 Eden 区内存不足时触发。因此出现 Major GC 时可能也会伴随着至少一次的 Minor GC。
- Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发。



根据内存对象的不同，常用的垃圾回收算法有以下几种：

### 标记-清除法（Mark-Sweep）

主要分为两个阶段：标记阶段标出所有需要回收的对象；清除阶段将 GC 检测中标记的对象直接清除。

虽然实现简单，但是会存在两个不足：效率不高；产生大量内存碎片。



### 复制法（Copying）

把空间分为两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。这种方法能解决标记-清除法的不足，但是会造成空间利用率低下，因为大多数新生代都不会熬过第一次 GC，所以没必要 1:1 的划分空间。

一种解决方案是：分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当进行垃圾回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。三者的大小一般是 8:1:1，每次需要浪费 10% 的 Survivor 空间。如果存活的对象所占内存空间大于 10%，就采用一种分配担保策略 —— 多出来的对象直接进入老年代。

这种做法不容易产生内存碎片，但是由于要保留一部分内存空间作为复制写入使用，因此可用的空间会减少。如果存活对象较多时，效率低下。



### 标记-整理法（Mark-Compact）

不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是先标记存活对象，然后把存活对象移到内存的一端，清理掉端边界以外的内存。

这种做法同样不容易产生内存碎片，而且内存的利用率高。但是存活对象比较分散的时候，内存操作的移动次数比较多，效率低下。



### 分代回收（目前大部分 JVM 的垃圾收集器采用的算法）

对于新生代，每次垃圾回收都有大量对象死去，只有少量存活，选用**复制算法**比较合理。

对于老年代，对象存活率较高，没有额外的空间分配对它进行担保。所以通常使用**标记-整理**法回收。

在堆外存在一个替代永久代的 MetaSpace 区，主要回收无效的类和常量。



## 回收方法区

在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。永久代垃圾回收主要两部分内容：

- 废弃常量：一般是没有该常量的引用。
- 无用的类：要以下三个条件都满足
    - 该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例
    - 加载该类的 ClassLoader 已经被回收
    - 该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法



## 垃圾回收器





