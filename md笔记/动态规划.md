# 动态规划



动态规划实质上就是在有向无环图上寻找单源点的最短路径。也就是有一个初始状态，根据某些条件，以当前状态为基础，不断向后转移，最终根据要求取出最优解。动态规划有一些很经典的题型，一旦看到这些相应的特征，就可以考虑使用动态规划的方法解答。



## 斐波那契系列

在数学上，斐波那契数列定义为：F(0) = 0，F(1) = 1, F(n) = F(n-1) + F(n-2)，n >= 2 且 n 为整数。



### 斐波那契数列

求 F(n)。

由此可以看出，斐波那契数列的主要特征就是递归，通过前两个元素决定当前元素的值，因此可以使用动态规划。常见的解题方法有：

* 递归调用（容易栈溢出、且重复计算多）

* ```java
    int Fab(int n) {
        if (n == 1 || n == 2) return 1;
        return Fab(n - 1) + Fab(n - 2);
    }
    ```

* 迭代求值，用数组保留中间值（保存中间值造成额外的内存消耗）

* ```java
    int Fab(int n) {
        if (n == 1 || n == 2) return 1;
        int[] l = new int[n+1];
        l[1] = 1, l[2] = 1;
        for (int i = 2; i < n; ++i) l[i] = l[i - 1] + l[i - 2];
        return l[n];
    }
    ```

* 使用临时变量保存连续的三个值。

```java
int Fab(int n) {
    int a = 1, b = 1;
    int tmp;
    for (int i = 3; i <= n; ++i) {
        tmp = a;
        a = b;
        b = tmp + a;
    }
    return b;
}
```



### 矩形覆盖

用 2\*1 的小矩形可以横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1的小矩形无重叠地覆盖一个 2\*n 的大矩形，共有多少种方法？

画出 n = 1, 2, 3, 4 的结果后，能够发现，对于某一个 n 的结果，它是通过在 n-1 的结果的右方竖着添加一块小矩形，以及在 n-2 的结果的右方添加两块横着的小矩形而得到的。因此递推公式为  f(n) = f(n - 1) + f(n - 2)，同样是一个斐波那契数列。



### 跳台阶

一只青蛙一次可以跳上一个台阶，也可以跳上两个台阶，求该青蛙跳上一个 n 级的台阶共有多少种跳法。

因为到达某一个台阶，可以从前一级跳一个台阶到达，也可以从前两级跳两个台阶到达，所以我们首先可以假设跳到 i 级台阶有 f(i) 种跳法，到 i + 1级台阶有 f(i + 1) 种跳法。那么到达第 i + 2 级台阶就可以从第 i 级或者第 i + 1 级到达。因此：f(i + 2) = f (i + 1) + f(i)。调整一下可以得到 f(n) = f(n - 1) + f(n - 2)。优化思路就跟斐波那契系列问题类似了。



### 字符转化

给定一个 0-9 组成的字符串，对应字母表顺序可转化成相应的大写字母，即 1 转化成 A，2 转化成 B ... 25 转化成 Y，26 转化成 Z。给定一个全为数字的字符串，求能转化得到的所有字符串共有多少种？

根据题意可以看出转化的方法有两种：

* 单个数字转化为对应字母；
* 与前一个数字组合转化为对应字母。

遍历字符串中某个位置时，可转化的字符串数量受之前位置的结果以及当前位置转化的结果所决定的。假设遍历到当前位置为 n，如果 n 位置与 n - 1 位置组成的两位数大于 26，那么就不能组合后再转化，则 f(n) = f(n - 1)；否则 f(n) = f(n - 1) + f(n - 2)。同样是一个斐波拉契数列形式的问题。



## 矩阵系列问题

矩阵系列问题通常类似于在一个有向带权的方格图里寻找最优路径的问题。常见的一些问题有：



### 最小路径和

给定一个由数字组成的矩阵，初始位置在左上角，要求每次只能向下或者向右移动一步，路径和就是经过的数字之和，求可能的最小路径和。

对于这类问题，我们可以分析它的状态转移方式，由于只能向下或者向右移动一步，因此对于当前位置而言，到达该位置的最小路径和为上方或者左侧的较小路径和加上当前位置的值，也就是：（其中 i 为行，j 为列）
$$
f[i][j] = min(f[i-1][j], f[i][j-1]) + num[i][j]
$$
但我们要考虑到，对于最左的列，它只能从上往下走得到；对于最上面的行，只能从左向右走得到。因此，我们在执行上述状态转移方程之前，先把第一行和第一列进行初始化。



### 其他问题

对于矩阵，除了求最小路径和，还有其他问题如求最大路径和、求可能的线路数目等。方法与求最小路径和类似。



## 背包问题

背包问题是一类经典的动态规划问题，通常的表述为：

> 有 N 件物品和一个容量为 V 的背包，现在物品 i 的费用为 w[i]，价值为 v[i]， 求将哪些物品装入背包可使得总价值最大？



### 01 背包

01 背包是最基础的背包问题，其主要特点是，**每个物品仅有一件**，可以选择放（表示 1）或者不放（表示 0）。

定义子问题状态为：f[i]\[j] 表示从前 i 件物品取物品放入容量为 j 的背包中可以获得的最大价值。状态转移方程为：
$$
f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i])
$$
状态转移方程体现出现的策略是：到达第 i 个物品时，其状态只牵扯到第 i - 1 个物品的结果。如果不放入 i 物品，那个价值 f[i]\[j] 与 f[i - 1]\[j] 相同，且背包容量相同。如果放入 i 物品，考虑到为了得到最大价值，就要尽可能多的使用背包的容量，因此期望放入 i 物品后，背包完全装满，即放入 i 物品前，背包最大容量应为 j - w[i]。然后在从上述两个情况下取较大值。

01 背包问题要求出 V * N 个状态，因此复杂度为 O(VN)。

### 完全背包

完全背包问题的背景类似，但主要区别是，**每种物品有无数件**，也就是说可以选择不放，或者放 1 个、2 个、3 个等等。如果按照 01 背包的思路，那么状态转移方程为：
$$
f[i][j] = max(f[i - 1][j], f[i - 1][j - k*w[i]] + k*v[i])
$$
其中 k 满足 0 <= k * w[i] <= j。



与 01 背包问题相比，当增加物品 i 可选后，01 背包问题考虑的是要不要放入这个物品 i，因此它是在已考虑 i - 1 物品后放入物品 i 而增加占用的容量，取**的 f[i - 1]\[j - w[i]]**；而完全背包考虑的是要不要再放入一个物品 i，有可能在这之前已经放有物品 i，也可能没有，所以它是在已考虑 i 物品且当前未再放入一个物品 i 时占用的背包容量，取的 **f[i]\[j - w[i]]** 的状态。

所以，优化后的状态转移方程为：
$$
f[i][j] = max(f[i - 1][j], f[i][j - w[i]] + v[i])
$$


通俗一点地说，01 背包和完全背包的区别在于，01 背包更多地考虑有没有**新的物品 i** 可以放进去，完全背包更多地考虑有没有**足够的容量**再放物品 i 进去。



### 多重背包

多重背包的条件是，物品 i 最多有 p[i] 件可用。









