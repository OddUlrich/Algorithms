# TCP 三次握手与四次挥手的异常处理

![img](https://pic4.zhimg.com/80/v2-0673bbc84fe4440aed9d1dadc67ae79b_720w.jpg)

## 三次握手的异常情况

### 1. 客户端第一个 SYN 包丢失

如果客户端第一个 SYN 包丢失了，对于服务器而言，它根本不知道客户端曾经发送过包，那么处理流程主要在于客户端。

在 TCP 协议里的一个主要原则是，某一端进行的“请求-应答”过程，在一定时间内并没有收到应答的 ACK 包，均认为是丢包，这个时候会出发重传机制，无论是对方没有收到自己的请求包，还是对方的应答包自己没有收到。

因此，此时客户端会开始重传 SYN 包。根据《TCP/IP 详解卷 I：协议》的描述，重传流程会尝试三次，间隔时间依次为 5.8s、24s、48s，三次总时长约为 76s。而大多数伯克利系统将建立一个新连接的最长时间限定为 75s。

所以，如果在三次握手中第一个 SYN 丢失了，客户端会进行重传，总的尝试时间为 75s。

### 2. 服务器端收到 SYN，回复的 SYN、ACK 包丢失

正如上面的分析，对于客户端来说，它会认为最开始发送的那个 SYN 包丢失了，于是会进入重传流程。

对于服务器而言，在回复 SYN、ACK 报文后，会等待客户端的下一个应答，但由于包丢失，因此超过等待应答的时候后同样会启动重传。此时服务器将处于 SYN_RCVD 状态，且会依次等待 3s、6s、12s 后，重新发送 SYN、ACK 包。对于不同的操作系统，一般配置会设定不同的重传次数，如 Linux 系统通常默认重传 5 次。如果在重传次数内仍未能收到 ACK 应答包，那么服务器端会自动关闭这个连接。

在这个过程中，如果服务器接收到来自客户端的重传 SYN 包，会重新发送 SYN、ACK 包。由于有序列号作为标识，因此能够避免建立起重复的连接。

 ### 3. 客户端最后一次回复 SYN、ACK 的 ACK 包丢失

由于客户端收到了 SYN、ACK 包，此时客户端会进入 ESTABLISHED 状态；而服务器因为没有收到 ACK 包，会认为是自己回复的 SYN、ACK 包丢失，从而会走上面所说的重传流程。

在大多数情况下，客户端已经进入 ESTABLISHED 状态，因此会认为连接已经成功建立，就会开始向服务器端发送数据。此时服务器处于 SYN_RCVD 状态。有些资料写的是，当服务器收到客户端发送的数据包后，会直接回复 RTS 包响应，表示服务器错误，并且进入 CLOSED 状态。但是在实际环境中，此时服务器会认为连接已经建立，并立即进入 ESTABLISHED 状态。这是因为客户端开始发送数据包时，会在数据包内携带一个 ACK 的确认序号，即使回复 ACK 包在传输过程中丢失了，当服务器接收到这个数据包时，能够通过数据包里的 ACK 确认序号来识别对应的连接，正常进入 ESTABLISHED 状态。

### 4. 客户端故意不发送最后一个 ACK 包

从上面的分析可以得知，此时服务器端处于 SYN_RCVD 状态，且会进行一系列的重传。但如果短时间内存在大量这样的不回复最后一个 ACK 包的连接请求，服务器就会承载很大的压力，这就是所谓的 SYN FLODD 攻击。这个就属于安全攻防的范畴了。



![img](https://pic2.zhimg.com/80/v2-8bf6f231cdd87b2613554f54424e8201_720w.jpg)

## 四次挥手的异常情况

### 1. 客户端请求断开连接的 FIN 丢失

在一定时间没有收到应答，客户端会认为 FIN 包丢失，则触发超时重传机制，并不会关心实际上是 FIN 包丢失还是对方的 ACK 包丢失。直到尝试所有重传次数后，仍没有收到应答 ACK 包，那么会直接关闭连接。

对于服务器而言，它并没有收到来自客户端的 FIN 请求，因此还是会正常工作，有可能会根据建立连接时的配置设置，在一定时间不通信后自动关闭连接。

### 2. 服务器端第一次回复的 ACK 丢失

根据上面的分析，客户端会进入重传 FIN 包的流程。如果服务器能收到，则立即会回复 ACK，进入正常的操作流程。

在正常情况下，服务器接收到客户端的 FIN 包后，会回复一个 ACK 包，并进入 CLOSED_WAIT 状态，开始做断开连接前的准备工作。当准备好之后，会向客户端发送一个 FIN、ACK 包，这里的 ACK 指的是携带了上一个 ACK 的响应序号说明这一个 FIN 请求是跟这个 ACK 响应序号对应的那次请求匹配的。

只要这个包没有丢失，那么当客户端接收以后，可以凭借包里的 ACK 响应序号，直接从 FIN_WAIT_1 状态，进入到 TIME_WAIT 状态，开始长达 2MSL 的等待。（正常情况是客户端发送 FYN 包后进入 FIN_WAIT_1 状态；接收到来自服务器的 ACK 包后，进入 FIN_WAIT_2 状态；接收到来自服务器的 FIN 包后，再进入 TIME_WAIT 状态）。

### 3. 服务器端发送的 FIN 丢失

此时服务器端并不知道是自己发送的 FIN 丢失还是客户端回复的 ACK 丢失，因此都会触发超时重传机制。

根据上面的分析，客户端可能处在 FIN_WAIT_1 状态，可能处于 FIN_WAIT_2状态，也可能处于 TIME_WAIT 状态，开始 2MSL 的等待。如果经过一定时间后仍然没有收到，那么客户端会自动断开连接；如果在客户端离开前收到了来自服务器端的 SYN 包，那就会回复一个 ACK 包，并且做好自己的状态切换。

### 4. 客户端最后回复的 ACK 丢失

对于客户端而言，就是在 2MSL 时间内等待服务器端的回复，之后便断开连接。对于服务器端而言，由于没有收到 ACK 回复，因此会重传一定次数直至服务器重传超时后主动断开。如果在这过程中有新的客户端加入，并且收到了服务器端的 FIN 消息，那么就会回复一个 RST 消息，服务器端接收到 RST 包后，会复位自己的状态（这个通常是新客户端接入或者客户端断开重连的情况）。

### 5. 客户端收到 ACK 后，服务器端跑路了

此时客户端处于 FIN_WAIT_2 状态，等待服务器的 FIN 包。但由于服务器跑路，因此这个包永远都等不到。

在 TCP 协议中，并没有对这个状态的处理机制，但是系统会接管这个状态。例如在 Linux 系统中，当超过设置的超时时间后，客户端会直接进入 CLOSED 状态。

### 6. 客户端收到 ACK 后，客户端自己跑路了

此时服务器端处于 LAST_ACK 状态，由于没有收到客户端的 ACK 回复，因此会不断尝试重传 FIN 包。

根据上面的分析，此时会有两种情况：一是经过一定时间后，服务器主动断开连接；二是有新的客户端接入，并向服务器发送的 SYN 请求，但这个 SYN 请求会被服务器忽略，并直接回复之前的那个 FIN、ACK 包。新客户端不会承认这个包，因此会发送一个 RST 消息，告诉服务器此时处于错误状态，需要复位两者之间的连接状态。