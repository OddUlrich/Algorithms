# TCP 与 UDP

TCP/IP 协议是一个协议簇。里面包括很多协议的，UDP 只是其中的一个。



## TCP （Transmission Control Protocol）

TCP/IP 协议集包括应用层，传输层，网络层，网络访问层。 

TCP 是面向连接的**单播**协议。在收发数据前，必须和对方建立可靠的连接。它是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供**全双工通信**，支持**半关闭连接**，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。



### 三次握手

![img](https://pic4.zhimg.com/80/v2-0673bbc84fe4440aed9d1dadc67ae79b_720w.jpg)

一个 TCP 连接必须要经过三次“握手”才能建立起来。其过程为：

1. 第一次握手：主机 A 通过向主机 B 发送一个含有**同步序列号（SYN）**标志位的数据段给主机 B，向主机 B 请求建立连接，seq = x 表示主机 A 自己的初始序号（第 x 号包）。通过这个数据段， 主机 A 告诉主机 B 两件事：我想要和你通信；你可以用那个序列号作为起始数据段来回应我。（SYN = 1，seq = x，**主机 A 进入 syn_sent 状态**，该数据包不能携带数据）
2. 第二次握手：主机 B 收到主机 A 的请求后，用一个带有**确认应答（ACK）**和**同步序列号（SYN）**标志位的数据段响应主机 A，ACKnum 表示期望收到对方下一个报文段的第一个数据字节序号是 x+1，seq = y 表示主机 B 自己的初始序号（第 y 号包）。同时也告诉主机 A 两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号（x+1）作为起始数据段来回应我。（SYN = 1，ACK = 1，ACKnum = x+1，seq = y，**主机 B 进入 syn_rcvd 状态**）
3. 第三次握手：主机 A 收到这个数据段后，再发送一个**确认应答（ACK）**，ACKnum 表示期望收到对方下一个报文段的第一个数据字节序号是 y+1，同时**携带要发送给主机 B 的数据**（通常为一些配置信息，如滑动窗口的大小）。确认已收到主机 B 的数据段："我已收到回复，我现在要开始传输实际数据了“。（ACK = 1，ACKnum = y+1）一旦主机 B 收到确认后，这样3次握手就完成了，这个 TCP 连接进入 **Established 状态**，主机 A 和主机 B 就可以传输数据了。

> 经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。在进行最少次交互的情况下完成了两端的**资源分配**和**初始化序号**（客户端 --> 服务器端： x。服务器端 --> 客户端：y）的交换。
>
> 
>
> 之所以不只是进行两次握手，而有第三次握手，是为了**防止失效的连接请求到达服务器，让服务器错误打开连接**。采用三次握手，当服务器接收并且回复确认了那条失效的连接请求，此时客户端不会再次发出确认，由于服务器得不到确认，那么就能知道客户端并没有请求该连接。



三次“握手”的目的是使数据包的发送和接收同步， 经过三次“握手”之后，主机 A 才向主机 B 正式发送数据。三次握手并不会涉及应用层的数据 , SYN 这个标志位只有在 TCP 建立连接时才会被置 1 ,握手完成后 SYN 标志位被置 0。



### 四次挥手

![img](https://pic2.zhimg.com/80/v2-8bf6f231cdd87b2613554f54424e8201_720w.jpg)

1. 当主机 A 完成数据传输后，将控制位 FIN 置1，提出停止 TCP 连接的请求 ；（FIN_WAIT_1）
2. 主机 B 收到 FIN 后对其作出响应，确认这一方向上的 TCP 连接将关闭，将 ACK 置 1，**避免引发不必要的 FIN 重传**；（FIN_WAIT_2 - CLOSE_WAIT）
3. 由 B 端再提出反方向的关闭请求，将 FIN 置 1；（LAST_ACK)
4. 主机 A 对主机 B 的请求进行确认，将 ACK 置 1，双方向的关闭结束.。

TCP 连接是双向传输的、对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK 确认关闭连接。注意，接收到 FIN 报文的一方只能回复一个 ACK , 它是无法马上返回对方一个 FIN 报文段的，因为**结束数据传输的“指令”是上层应用层给出的**，我只是一个“搬运工”，我无法了解“上层的意志”。

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，**仅仅表示对方不再发送数据了但是还能接收数据**，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。



> TCP 的四次挥手有可能变成三次挥手。之所以断开 tcp 连接需要四次挥手（2 + 2）是因为 tcp 是全双工通信且支持**半关闭连接**，即两端向对方传输数据和终止在时序上是独立的。
>
> 但如果服务器端收到客户端的 FIN 包后，也没数据要发送给客户端了，那么回复给客户端的 ACK 包和服务器自己的 FIN 包就可以合并成一个包发送过去。这样四次挥手就编程三次了。
>
> 实际上有时候在抓包时会看到 FIN+ACK这样的数据包，即三次挥手释放 tcp 连接的数据包，这是因为现在大多数实现都允许连接终止时使用三次挥手（但大部分情况下，还是以四次挥手为主）。三次挥手适合在双方都没有数据要发送的情况下。



由 TCP 的三次握手和四次断开可以看出，TCP 使用面向连接的通信方式，大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。



### TCP 的短连接和长连接

**短连接：**Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。

短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

**长连接：**Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。

长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略



## UDP （User Data Protocol）

UDP 是用户数据报协议，它是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP 传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。UDP 信息包的标题很短，只有 8 个字节，相对于 TCP 的 20 个字节信息包的额外开销很小。吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。

UDP 使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文， 在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

我们经常使用 ping 命令来测试两台主机之间 TCP/IP 通信是否正常， 其实 ping 命令的原理就是向对方主机发送UDP 数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。



